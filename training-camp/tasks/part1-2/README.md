# 模块1-2： ES新特性与TypeScript、JS 性能优化

## 简答题

### 一、请说出下列最终的执行结果，并解释为什么。

```js
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[6]()
```

答：执行结果是 10 ，这边 for 循环的 i 是用 var 定义的，所以 i 属于全局变量，而每个数组的函数都是直接去访问全局变量的 i 。当调用 a[6]() 的时候，i 已经被加到 10 了，所以最终打印的是 10 。

### 二、请说出下列最终的执行结果，并解释为什么。

```js
var tmp = 123
if (true) {
    console.log(tmp)
    let tmp
}
```

答：这边应该是报错。打印语句是在 if 的大括号里，属于块级作用域。而块级作用域里检测到有使用 let 定义的 tmp 变量，也就是存在一个名为 tmp 的块级作用域变量，因此不会去使用全局作用域的 tmp。而 let 定义的变量不会变量提升，这边在定义变量之前就去使用它，就会报不能在定义之前访问的错误。

### 三、结合 ES6 新语法，用最简单的方式找出数组中的最小值。

```js
var arr = [12, 34, 32, 89, 4]
```

答：

```js
Math.min(...arr)
```

### 四、请详细说明 var， let， const 三种声明变量的方式之间的具体差别。

答：

- let 和 const 属于块级作用域，var 如果放在全局下就是全局作用域，如果放在函数里就是函数作用域；
- var 会变量提升，可以在变量声明之前使用，而 let 和 const 不行；
- const 定义后不可修改，而 var 和 let 可以
- let 和 const 在同作用域下不能定义相同的变量名，而 var 可以

### 五、请说出下列代码最终输出的结果，并解释为什么。

```js
var a = 10
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```

答：最终输出 20 。这边 `fn () {}` 相当于 `fn: function () {}` ，是个普通函数，所有 fn 函数体里面的 this 是指向 obj。而 setTimeout 传是一个箭头函数，箭头函数不会改变 this 的执行，所以 this.a 是指向 obj.a ，所以最终打印 20。

### 六、简述Symbol类型的用途。

答：

- 用于创建独一无二的值
- 可用于模拟实现对象的私有成员
- 用来重置对象的属性，比如 Symbol.toStringTag
- 可实现 Symbol.iterator 让普通对象变为可迭代对象

### 七、说说什么是浅拷贝，什么是深拷贝？

答：浅拷贝是复制地址，深拷贝是复制值

### 八、请简述 TypeScript 与 JavaScript 之间的关系。

答：TypeScript = JavaScript + 类型系统 + ES6+新特性

### 九、请谈谈你所认为的TypeScript优缺

优点：

- 错误更早暴露
- 有代码提示
- 重构更牢靠
- 减少不必要的类型判断

缺点：

- 增加了一些前期一些额外工作量，不适合小型项目
- 对于不熟的人前期开发效率会降低

### 十、描述引用计数的工作原理和优缺点。

工作原理：设置引用数，判断当前引用数是否为 0 ，引用数为 0 时立即回收

优点：

- 发现垃圾时立即回收
- 最大限度减少程序暂停

缺点：

- 无法回收循环引用的对象
- 时间开销大


### 十一、描述标记整理算法的工作流程。

答：标记整理算法分为标记阶段、整理阶段、清除阶段。

- 标记阶段会从根出发查找所有可达对象，并进行标记。
- 标记完成后将所有标记对象移动到一边，空间区域和没标记对象整理到另一边。
- 清除所有非标记对象


### 十二、描述V8中新生代存储区垃圾回收的流程。

答：回收过程采用：复制算法 + 标记整理

- 新生代内存区分为二个等大小空间
- 使用空间为From，空闲空间为To
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To
- From与To交换空间完成释放

### 十三、描述增量标记算法在何时使用及工作原理。

使用场景：当标记阶段需要花很长时间的时候，比如对象较多或嵌套曾经较深的时候。
工作原理：将连续的垃圾回收拆分成多个 ”小步“ 与程序运行交替完成，提高效率。